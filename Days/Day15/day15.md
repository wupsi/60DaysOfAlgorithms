# Quick Sort - Day 15

## Problems

### HackerEarth
- [✔️] [A. A cricket tournament](https://www.hackerearth.com/practice/algorithms/sorting/quick-sort/practice-problems/algorithm/chef-and-chefa-a5c8800a/)

### Leetcode

- [✔️] [A. Sort an Array](https://leetcode.com/problems/sort-an-array/)
- [✔️] [B. Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/submissions/)


## Quick Sort

**Быстрая сортировка** - еще один алгоритм сортировки, считающийся одним из быстрейших, который в среднем работает за время `O(nlog(n))`. Перейдем к реализации.

**Первое**, что мы сделаем - определим опорный элемент в массиве. Определив опорный элемент, относительно его мы будем сравнивать элементы с левой и правой части. Возьмем следующий массив для примера:
`[1, 7, 5, 4, 2, 8, 0]`
Пусть опорным элементом будет центральный. Тоесть 4, индекс которого равен 3. `arr[3] = 4`. 
*Вообще, опорный элемент может быть любым в массиве, но для нашего примера мы возьмем центр массива.*

**Второе**, что надо будет сделать, найти элемент больше опорного с левого массива, и элемент меньше опорного с правого массива. Для начала объявим сам опорный элемент `middle = arr[(left + right) / 2]`, где `left` - указатель на начало массива, `right` - указатель на конец массива. 
```
		 mid	 right
		  v	       v
[1, 7, 5, 4, 2, 8, 0]
 ^
left
```
Также добавим еще 2 вспомогательных указателя. `l = left`, `r = right`.  Они и будут передвигаться по левой и правой части. 
Сначала возьмем левую часть: пока не дойдем до элемента, который является больше опорного, будем увеличивать `l`.
```
while(mid > arr[l]) l++;
```
Также и с правой стороной: пока не дойдем до элемента, который меньше опорного, будем уменьшать `r`.
```
while(mid < arr[r]) r--;
```
В один момент оба цикла закончатся, `arr[l]` слева больше опорного, `arr[r]` справа меньше опорного:
```
    l			   r
    v			   v
[1, 7, 5, 4, 2, 8, 0]
		  ^
		 mid
```
Тогда мы и поменяем эти элементы местами.
`[1, 0, 5, 4, 2, 8, 7]`
После чего передвинемся к следующим элементам:
```
       l     r
       v	 v
[1, 0, 5, 4, 2, 8, 7]			// 8 больше опорного, поэтому его пропустим
		  ^
		 mid
```

Меняем их местами: `[1, 0, 2, 4, 5, 8, 7]`
Дальше `l` выйдет за `r`, это и будет моментом остановки цикла.
```
int l = left, r = right;
int mid = arr[(left + right) / 2];

while(l <= r){
	while(arr[l] < mid) l++;
	while(arr[r] > mid) r--;
	if(l <= r) swap(arr[l++], arr[r--]);
}
```

**Третьим** шагом будет рекурсивный вызов функции, на этот раз вместо всего массива мы передадим отрезок `[left, r]`, левую часть массива, и `[l, right]`, правую часть массива. Тогда левый и правый отрезок пройдут первый и второй шаг повторно. И продолжаться это будет до тех пор, пока `left` будет меньше `right`.

```
void QuickSort(int arr[], int left, int right){
	if(left < right){
		int l = left, r = right;
		int mid = arr[(left + right) / 2];
		while(l <= r){
			while(arr[l] < mid) l++;
			while(arr[r] > mid) r--;
			if(l <= r) swap(arr[l++], arr[r--]);
		}
		QuickSort(arr, left, r);
		QuickSort(arr, l, right);
	}
}
```

Протестим:
```
int main(){
  
	int n = 7;
	int arr[n] = {1, 7, 5, 4, 2, 8, 0};
	  
	QuickSort(arr, 0, n - 1);
	
	for(int i = 0; i < n; i++)
		cout << arr[i] << " ";
}
```
`Output:`
```
0 1 2 4 5 7 8
```

## Использованные материалы
- [Быстрая сортировка - acmp](https://acmp.ru/asp/do/index.asp?main=topic&id_course=1&id_section=7&id_topic=119)
- [Быстрая сортировка - Википедия](https://ru.wikipedia.org/wiki/Быстрая_сортировка)
- [Быстрая сортировка - YouTube, Данила Сысоев](https://www.youtube.com/watch?v=9wqFEyeu3D8)