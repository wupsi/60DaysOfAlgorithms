
## Stack, Queue, Deque - Day 2

В течении следующих двух дней рассмотрим структуры данных stack, queue, deque. Разберем структуру(struct), приватность и публичность переменных и функции.

## Stack

Стек — это структура данных, которая работает по принципу **FILO** (first in - last out; первый пришел - последний ушел). В C++ уже есть готовый шаблон — `stack`. Но сегодня шаблон мы использовать не будем, вместо этого попытаемся реализовать структуру `stack` сами.

Стек имеет следующие 5 функции:
```
push(x)			Вставляет в стек x
pop() 			Удаляет верхний элемент стека
empty() 		Проверяет стек на пустоту
size() 			Возвращает размер стека
top() 			Возвращает верхний элемент стека
```
Для того, чтобы полноценно понять структуру стека, первым делом рассмотрим пример с готовым шаблоном стека:
```
int  main(){

	stack<int> st; 					// объявили стек st
	int n; cin >> n; 				// вводим n
	
	for(int i =  0; i < n; i++){	// вводим n элементов
		int num; cin >> num;
		st.push(num); 				// каждый введенный num вставляем в стек
	}
	
	while(!st.empty()){ 			// пока стек не будет пуст, делаем следующее:
		cout << st.top() <<  " "; 	// выводим верхний элемент стека
		st.pop(); 					// удаляем верхний элемент стека
	}
}
```
```
Input:
5
1 2 3 4 5

Output:
5 4 3 2 1	
```
Еще раз наглядно:
```
stack<int> st;			// объявили пустой стек []. Ниже будет содержимое стека в скобках
st.push(1);				// [1]
st.push(2);				// [2, 1]
st.push(3);				// [3, 2, 1]
st.push(4);				// [4, 3, 2, 1]
st.push(5);				// [5, 4, 3, 2, 1]
st.pop();				// [4, 3, 2, 1]
st.pop();				// [3, 2, 1]
```
**First in - last out** — первый введенный выходит последним, а последний введенный выходит первым. 

### Реализация структуры

Что такое стек - мы уже разобрались, теперь попробуем реализовать без использования готового шаблона. Для реализации любой структуры имеется ключевое слово `struct`, а его формат выглядит следующим образом:

```
struct название_структуры{
	
	компоненты_структуры;
	
	методы_структуры(){
		// код метода
	}
};
```

Как мы помним, стек имеет 5 функций - `push`, `pop`, `top`, `empty`, `size`.
`top`, `empty` и `size` возвращают некие значения, в то время как `push` и `pop` ничего не возвращают. Также `push` должен принимать данные. Тогда:

```
struct stack{

	void  push(int  x){
	}
	
	void  pop(){
	}

	int  top(){
	}

	bool  empty(){
	}

	int  size(){
	}

};
```

На начальном этапе допустим, что вводные данные только целые числа. Шаблон есть, теперь разберемся с логикой. Первое, что приходит в голову - создать массив  и пробегаться по элементам счетчиком. Пусть будет компонент `pos = 0`. Также массив размером побольше, чтоб уж наверняка: `arr[100000]`.  Стоит отметить: чтобы присвоить какое-либо значение компонентам внутри структуры, необходимо прописывать присвоения в отдельной функции, скелете структуры. 

```
struct stack{
	
	int pos;						// объявление компонентов pos и arr[]
	int arr[100000];
	
	stack(){			
		pos = 0;					// присваиваем значение
	}

	void push(int x){				// метод ввода
		arr[pos++] = x;				// в массив с индексом pos присваиваем число x,
	}								// затем увеличиваем pos, чтобы следующий ввод x был на новом индексе

	void pop(){						// метод удаления
		if(!empty())				// если стек не пустой
			pos--;					// уменьшаем pos, тем самым просто пропускаем конечный элемент
		else						// защита от ошибок
			cout << "ERROR\n";		// если стек пуст и была вызвана метод удаления, выведем ошибку
	}
	
	int top(){						метод вывода верхнего элемента
		if(!empty())
			return arr[pos -  1];
		else						// защита от ошибок
			return -9999999;		// если стек пуст и была вызван метод вывода, возвратим -9999999.
	}								// без возвращаемого элемента метод работать не будет

	 bool empty(){					// метод для проверки на пустоту
		return pos == 0;			// если pos == 0, значит 0-й индекс массива не заполнен
	}								// соответственно стек пуст, возвращаем True. return возвратит результат условия.
	
	int size(){						// метод возврата размера
		return pos;					// размер стека в любом случае равен компоненту pos
	}
};
```

Компонент `pos` будет пробегаться по массиву. По началу он равен нулю, но как только мы введем элемент, `arr[0]` присвоит себе значение вводимого пользователем числа, а pos увеличится на единичку. Затем, в следующем вводе, `pos = 1`, поэтому на этот раз значение вводимого числа присвоит себе `arr[1]` и т.д. В случае удаления элемента, сначала мы будем проверять стек на пустоту. Если он не пустой, мы просто уменьшаем `pos`, и к примеру было 2 элемента в стеке, тогда `pos = 2`(так как `arr[0]` и `arr[1]` заполнены, следующий элемент будет `arr[2]`), при удалении мы лишь уменьшаем `pos`(тогда `pos = 1`) и пропускаем последний заполненный элемент массива. В случае пустого стека также рассмотрена защита от ошибок. 
Протестируем структуру:
```
int  main(){

	stack st;		// Так объявляется структура. st - название, оно может быть любым
					// Методы в struct вызываются через точку
					
	st.push(1); 											// [1]
	st.push(2); 											// [2, 1]
	st.push(3); 											// [3, 2, 1]
	cout <<  "Stack size: "  << st.size() << endl; 			// 3
	cout <<  "Stack last element: "  << st.top() << endl;	// 3
	st.pop(); 												// [2, 1]
	cout <<  "Stack last element: "  << st.top() << endl; 	// 2
	st.pop(); 												// [1]
	cout <<  "Stack last element: "  << st.top() << endl; 	// 1
	st.pop(); 												// []
	cout <<  "Stack is empty? ";
	cout << (st.empty() ?  "YES\n"  :  "NO\n"); 			// YES
	cout <<  "Stack last element: "  << st.top() << endl; 	// -1
	st.pop(); 												// ERROR
	cout <<  "Stack last element: "  << st.top() << endl; 	// -1

}
```
```
Output:
Stack size: 3
Stack last element: 3
Stack last element: 2
Stack last element: 1
Stack is empty? YES
Stack last element: -9999999
ERROR
Stack last element: -9999999
```

### Спецификаторы доступа

По умолчанию члены структуры(компоненты и методы) являются публичными(public). Тоесть обращаться с `main` функции на члены структуры мы можем без проблем. Но порой это может стать помехой в работе в команде. Специально для таких случаев придуманы спецификаторы доступа. 

Всего есть 3 уровня доступа:
- **public** делает члены открытыми
- **private** делает члены закрытыми
- **protected** открывает доступ к членам только для дружественных и дочерних классов(нас это пока не интересует)

Обычно компоненты являются закрытыми, а методы — открытыми. В структуре это выглядит так:

```
struct stack{
	
	private:
		int pos;
		int arr[100000];

	public:	
		stack(){			
			pos = 0;
		}

		void push(int x){
			arr[pos++] = x;	
		}

		void pop(){
			if(!empty())
				pos--;
			else
				cout << "ERROR\n";
		}
		
		int top(){	
			if(!empty())
				return arr[pos - 1];
			else
				return -9999999;
		}

		 bool empty(){
			return pos == 0;
		}
		
		int size(){
			return pos;
		}
};
```
В структуре мы закрыли доступ к компонентам, к ним доступ имеют только другие члены структуры.

## Queue

## Использованные материалы

- [C++ | Структуры](https://metanit.com/cpp/tutorial/5.8.php)
- [Стек(stack) в C++](https://codelessons.ru/cplusplus/realizaciya-steka-stack-v-c.html)
- [stack - C++ Reference](https://cplusplus.com/reference/stack/stack/)
- [Спецификаторы доступа](https://ravesli.com/urok-114-spetsifikatory-dostupa-public-i-private/)